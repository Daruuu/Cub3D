#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

#define INVALID_LEN_FILE_MAP     "Error: Map filename too short.\n"
#define INVALID_MAP_EXTENSION    "Error: Invalid map extension. Expected '.cub'.\n"
#define ERROR_INVALID_FILENAME   "Error: Filename contains invalid characters.\n"
#define ERROR_FILE_NOT_FOUND     "Error: Map file could not be opened.\n"
#define ERROR_IS_DIRECTORY       "Error: The given map is a directory, not a file.\n"

static int	has_cub_extension(char *filename)
{
	const char	*extension = ".cub";
	int			len_filename = ft_strlen(filename);
	int			len_extension = ft_strlen(extension);

	// Si el nombre del archivo es m√°s corto que ".cub", no es v√°lido
	if (len_filename < len_extension)
		return (0);

	// Comparamos los √∫ltimos caracteres del nombre con ".cub"
	if (ft_strncmp(&filename[len_filename - len_extension], extension, len_extension) == 0)
		return (1);

	return (0);
}




static int	is_valid_filename_length(char *filename)
{
	return (ft_strlen(filename) > 4);
}

static int	has_invalid_chars(char *filename)
{
	while (*filename)
	{
		if (*filename == '*' || *filename == '?' || *filename == ':' ||
			*filename == '<' || *filename == '>' || *filename == '|')
			return (1);
		filename++;
	}
	return (0);
}

int validate_map_filename(char *filename)
{
	struct stat	sb;

	if (!is_valid_filename_length(filename))
		return (printf(INVALID_LEN_FILE_MAP), 1);
	if (!has_cub_extension(filename))
		return (printf(INVALID_MAP_EXTENSION), 1);
	if (has_invalid_chars(filename))
		return (printf(ERROR_INVALID_FILENAME), 1);

	if (open(filename, O_RDONLY) < 0)
		return (printf(ERROR_FILE_NOT_FOUND), 1);

	if (stat(filename, &sb) == 0 && S_ISDIR(sb.st_mode))
		return (printf(ERROR_IS_DIRECTORY), 1);

	return (0);
}


// ======= PARSER_FILE =======


//  FUNCTIONS WITHOUT USING:
srcs/parsing_file/parsing_file();




// ======= PARSER_MAP =======

//  FUNCTIONS WITHOUT USING:
srcs/parser_map/check_extension_and_player.c

    void	get_player_init_pos(t_parser *map_data);

//  FUNCTIONS WITHOUT USING:
srcs/parser_map/check_items.c

    int	validation_items_in_map(t_parser *map_info);

//  now here in check_items.c
    int	set_map_dimensions(t_parser *map_info);
    int	check_map_dimensions(t_parser *map_info);



static char	**new_matrix_map(t_parser *parser, int first_line, int total_lines)
{
	char	**matrix;
	char	*trimmed_line;
	int		rows;

	matrix = allocate_map_matrix(total_lines);
	if (!matrix)
		return (NULL);
	rows = 0;
	while (rows < total_lines)
	{
		trimmed_line = allocate_trimmed_line(parser->file_map[first_line + rows]);
		if (!trimmed_line || !copy_line_to_matrix_row(matrix, rows, trimmed_line))
		{
			free(trimmed_line);
			return (free_matrix(matrix), NULL);
		}
		free(trimmed_line);
		rows++;
	}
	matrix[rows] = NULL;
	parser->rows = rows;
	return (matrix);
}




static int	copy_line_to_matrix_row(char **new_matrix, char *trimmed_line, int row)
{
	int	len_line;
	int	i;

	len_line = (int) ft_strlen(trimmed_line);
	new_matrix[row] = malloc(sizeof(char) * (len_line + 1));
	if (!new_matrix[row])
		return (0); // error
	i = 0;
	while (i < len_line)
	{
		new_matrix[row][i] = trimmed_line[i];
		i++;
	}
	new_matrix[row][i] = '\0';
	return (1); // √©xito
}

static char	**new_matrix_map(t_parser *parser, int first_line, int total_lines)
{
	char	**new_matrix;
	char	*trimmed_line;
	int		rows;

	new_matrix = malloc(sizeof(char *) * (total_lines + 1));
	if (!new_matrix)
		return (NULL);
	rows = 0;
	while (rows < total_lines)
	{
		trimmed_line = ft_strtrim(parser->file_map[first_line + rows], " ");
		if (!trimmed_line || !copy_line_to_matrix_row(new_matrix, trimmed_line, rows))
		{
			free(trimmed_line);
			free_matrix(new_matrix);
			return (NULL);
		}
		free(trimmed_line);
		rows++;
	}
	new_matrix[rows] = NULL;
	parser->rows = rows;
	return (new_matrix);
}




int	validate_map_after_extract(t_parser *parser)
{
	int	i;

	if (!parser->original_map)
		return (1);

	if (parser->validation_map == NULL)
	{
		parser->validation_map = malloc(sizeof(char *) * (parser->rows + 1));
		if (!parser->validation_map)
			return (1);
		i = 0;
		while (i < parser->rows)
		{
			parser->validation_map[i] = ft_strdup(parser->original_map[i]);
			if (!parser->validation_map[i])
			{
				free_matrix(parser->validation_map);
				return (1);
			}
			i++;
		}
		parser->validation_map[i] = NULL;
	}

	normalize_and_fill_map(parser);

	if (validate_map(parser) == 1)
	{
		free_matrix(parser->validation_map);
		parser->validation_map = NULL;
		return (1);
	}

	return (0);
}

static int  process_line_and_set_type(char *line, t_parser *parser, t_assets *counter)
{
	char	*trimmed;
	int		result;

	if (!line || !parser || !counter)
		return (1);

	trimmed = ft_strtrim(line, " ");
	if (!trimmed)
		return (1);

	// No se procesa si la l√≠nea es muy corta
	if (ft_strlen(trimmed) <= 1)
	{
		free(trimmed);
		return (0);
	}

	result = type_of_horientation(parser, trimmed, counter);
	free(trimmed);
	return (result);
}

static int	set_texture_field(char **field, char *trim_line,
								int *counter, const char *error_msg)
{
	char	*tmp_clean_line;

	if ((*counter)++)
		return (printf("%s", error_msg), 1);

	tmp_clean_line = ft_strrchr(trim_line, ' ');
	if (!tmp_clean_line || *(tmp_clean_line + 1) == '\0')
		return (printf("Error: texture path missing or malformed: '%s'\n", trim_line), 1);

	*field = ft_strdup(tmp_clean_line + 1);
	if (!*field)
		return (printf("Error: memory allocation failed for texture path\n"), 1);

	return (0);
}



#include <string.h>  // strlen

int	validate_extension_xpm(char *path)
{
	size_t	len;

	if (!path)
		return (1);
	len = ft_strlen(path);
	if (len < 4)
		return (1);
	if (ft_strncmp(path + len - 4, ".xpm", 4) != 0)
		return (1);
	return (0); // v√°lido
}



static void	normalize_map_lines(char **validation_map, int rows, int max_columns)
{
	char	*new_line;
	int		i;
	int		len;
	int		j;

	i = 0;
	while (i < rows && validation_map[i] != NULL)
	{
		len = (int) ft_strlen(validation_map[i]);
		if (len <= max_columns)
		{
			new_line = malloc(sizeof(char) * (max_columns + 1));
			if (!new_line)
				return ;

			// Copiar y reemplazar espacios por FILL_MAP
			for (j = 0; j < len; j++)
				new_line[j] = (validation_map[i][j] == ' ') ? FILL_MAP : validation_map[i][j];

			// Rellenar el resto con FILL_MAP
			ft_memset(new_line + len, FILL_MAP, max_columns - len);
			new_line[max_columns] = '\0';

			free(validation_map[i]);
			validation_map[i] = new_line;
		}
		i++;
	}
}





static void normalize_map_lines(char **validation_map, int rows, int max_columns)
{
	char	*new_line;
	int		i;
	int		len;
	int		j;

	i = 0;
	while (i < rows && validation_map[i] != NULL)
	{
		len = (int)ft_strlen(validation_map[i]);
		if (len <= max_columns)
		{
			new_line = malloc(sizeof(char) * (max_columns + 1));
			if (!new_line)
				return ;

			// Copiar los caracteres existentes, reemplazando ' ' por FILL_MAP
			j = 0;
			while (j < len)
			{
				if (validation_map[i][j] == ' ')
					new_line[j] = FILL_MAP;
				else
					new_line[j] = validation_map[i][j];
				j++;
			}

			// Rellenar el resto de la l√≠nea con FILL_MAP
			while (j < max_columns)
			{
				new_line[j] = FILL_MAP;
				j++;
			}
			new_line[max_columns] = '\0';

			free(validation_map[i]);
			validation_map[i] = new_line;
		}
		i++;
	}
}
















static void	normalize_map_lines(char **validation_map, int rows, int max_columns)
{
	char	*new_line;
	int		i;
	int		j;
	int		len;
	int		k;

	i = 0;
	while (i < rows && validation_map[i] != NULL)
	{
		len = (int) ft_strlen(validation_map[i]);
		new_line = malloc(sizeof(char) * (max_columns + 1));
		if (!new_line)
			return ;

		j = 0;
		while (j < max_columns)
		{
			if (j < len)
			{
				if ((i == 0 || i == rows - 1 || j == 0 || j == max_columns - 1)
					&& validation_map[i][j] == ' ')
					new_line[j] = FILL_MAP;
				else
					new_line[j] = validation_map[i][j];
			}
			else
			{
				if (i == 0 || i == rows - 1 || j == 0 || j == max_columns - 1)
					new_line[j] = FILL_MAP;
				else
					new_line[j] = ' ';
			}
			j++;
		}
		new_line[max_columns] = '\0';

		// üÜï Reemplazar espacios iniciales hasta el primer '1'
		k = 0;
		while (k < max_columns && new_line[k] != '1')
		{
			if (new_line[k] == ' ')
				new_line[k] = FILL_MAP;
			k++;
		}

		free(validation_map[i]);
		validation_map[i] = new_line;
		i++;
	}
}














